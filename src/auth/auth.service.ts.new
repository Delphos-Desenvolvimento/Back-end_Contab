import { 
  Injectable, 
  UnauthorizedException, 
  ConflictException, 
  Logger, 
  BadRequestException,
  Inject,
  forwardRef
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import * as bcrypt from 'bcrypt';
import { PrismaService } from '../prisma/prisma.service';

export interface AdminUser {
  id: number;
  user: string;
  role: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface LoginResponse {
  access_token: string;
  user: AdminUser;
}

@Injectable()
export class AuthService {
  private readonly logger = new Logger(AuthService.name);
  private readonly saltRounds = 10;

  constructor(
    @Inject(forwardRef(() => PrismaService))
    private prisma: PrismaService,
    private jwtService: JwtService
  ) {}

  async validateUser(email: string, password: string): Promise<AdminUser | null> {
    try {
      const user = await this.prisma.admin.findUnique({ 
        where: { user: email },
        select: {
          id: true,
          user: true,
          password: true,
          role: true,
          createdAt: true,
          updatedAt: true
        }
      });
      
      if (!user) {
        return null;
      }

      const isPasswordValid = await bcrypt.compare(password, user.password);
      if (!isPasswordValid) {
        return null;
      }

      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const { password: _, ...result } = user;
      return result as AdminUser;
    } catch (error: any) {
      this.logger.error(`Error validating user: ${error.message}`, error.stack);
      throw new BadRequestException('Error validating user');
    }
  }

  async login(email: string, password: string): Promise<LoginResponse> {
    try {
      const user = await this.validateUser(email, password);
      
      if (!user) {
        throw new UnauthorizedException('Invalid credentials');
      }

      const payload = { 
        sub: user.id, 
        email: user.user,
        role: user.role 
      };

      return {
        access_token: this.jwtService.sign(payload, { expiresIn: '2h' }),
        user: user
      };
    } catch (error: any) {
      this.logger.error(`Login error: ${error.message}`, error.stack);
      throw new UnauthorizedException('Authentication failed');
    }
  }

  async createUser(email: string, password: string, role: string = 'USER'): Promise<AdminUser> {
    try {
      const hashedPassword = await bcrypt.hash(password, this.saltRounds);
      
      const user = await this.prisma.admin.create({
        data: {
          user: email,
          password: hashedPassword,
          role: role
        },
        select: {
          id: true,
          user: true,
          role: true,
          createdAt: true,
          updatedAt: true
        }
      });

      return user as AdminUser;
    } catch (error: any) {
      if (error.code === 'P2002') {
        throw new ConflictException('Email already exists');
      }
      this.logger.error(`Error creating user: ${error.message}`, error.stack);
      throw new BadRequestException('Error creating user');
    }
  }

  async getAllUsers(): Promise<AdminUser[]> {
    try {
      return await this.prisma.admin.findMany({
        select: {
          id: true,
          user: true,
          role: true,
          createdAt: true,
          updatedAt: true
        }
      });
    } catch (error: any) {
      this.logger.error(`Error fetching users: ${error.message}`, error.stack);
      throw new BadRequestException('Error fetching users');
    }
  }

  async getUserById(id: number): Promise<AdminUser | null> {
    try {
      return await this.prisma.admin.findUnique({
        where: { id },
        select: {
          id: true,
          user: true,
          role: true,
          createdAt: true,
          updatedAt: true
        }
      });
    } catch (error: any) {
      this.logger.error(`Error fetching user: ${error.message}`, error.stack);
      throw new BadRequestException('Error fetching user');
    }
  }

  async updateUser(id: number, updateData: Partial<AdminUser>): Promise<AdminUser> {
    try {
      return await this.prisma.admin.update({
        where: { id },
        data: updateData,
        select: {
          id: true,
          user: true,
          role: true,
          createdAt: true,
          updatedAt: true
        }
      });
    } catch (error: any) {
      this.logger.error(`Error updating user: ${error.message}`, error.stack);
      throw new BadRequestException('Error updating user');
    }
  }

  async deleteUser(id: number): Promise<void> {
    try {
      await this.prisma.admin.delete({
        where: { id }
      });
    } catch (error: any) {
      this.logger.error(`Error deleting user: ${error.message}`, error.stack);
      throw new BadRequestException('Error deleting user');
    }
  }

  async changePassword(id: number, currentPassword: string, newPassword: string): Promise<void> {
    try {
      const user = await this.prisma.admin.findUnique({
        where: { id },
        select: { password: true }
      });

      if (!user) {
        throw new UnauthorizedException('User not found');
      }

      const isPasswordValid = await bcrypt.compare(currentPassword, user.password);
      if (!isPasswordValid) {
        throw new UnauthorizedException('Current password is incorrect');
      }

      const hashedPassword = await bcrypt.hash(newPassword, this.saltRounds);
      
      await this.prisma.admin.update({
        where: { id },
        data: { password: hashedPassword }
      });
    } catch (error: any) {
      this.logger.error(`Error changing password: ${error.message}`, error.stack);
      throw new BadRequestException('Error changing password');
    }
  }
}
